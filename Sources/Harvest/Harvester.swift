import Combine

/// Deterministic finite state machine that receives "input"
/// and with "current state" transform to "next state" & "output (additional effect)".
public final class Harvester<State, Input>
{
    private let _state: CurrentValueSubject<State, Never>
    private let _replies: PassthroughSubject<Reply<State, Input>, Never> = .init()
    private let _cancelBag = CancelBag()

    /// - Parameters:
    ///   - initial: Initial state and effect (cold publisher).
    ///   - inputs: Hot input publisher.
    ///   - mapping: `EffectMapping` that designates next state and also generates additional effect (cold publisher).
    public init<InitialEffect: Publisher, Inputs: Publisher>(
        initial: (State, InitialEffect),
        inputs: Inputs,
        mapping: @escaping EffectMapping
    ) where
        InitialEffect.Output == Input, InitialEffect.Failure == Never,
        Inputs.Output == Input, Inputs.Failure == Never
    {
        let (initialState, initialEffect) = initial

        let currentState = CurrentValueSubject<State, Never>(initialState)
        self._state = currentState

        let internalInputs = PassthroughSubject<Input, Never>()

        /// Recursive inputs that sends inputs from `inputs`
        /// and also additional effects generated by `EffectMapping`.
        func recurInputs<Inputs: Publisher>(_ inputs: Inputs) -> AnyPublisher<Reply<State, Input>, Never>
            where Inputs.Output == Input, Inputs.Failure == Never
        {
            let mapped = inputs
                .map { input -> (Inputs.Output, State, (State, AnyPublisher<Input, Never>)?) in
                    let fromState = currentState.value    // TODO: Use withLatestFrom when supported
                    return (input, fromState, mapping(fromState, input))
                }
                .share()

            let success = mapped
                .compactMap { (input, fromState, mapped) in
                    mapped.map { (input, fromState, $0) }
                }
                .flatMap(maxPublishers: .unlimited) { (input, fromState, mapped) -> AnyPublisher<Reply<State, Input>, Never> in
                    let (toState, effect) = mapped
                    let reply = Reply<State, Input>.success(input, fromState, toState)
                    let p = recurInputs(effect)
                        .prepend(reply)
                    return AnyPublisher(p)
                }

            let failure = mapped
                .compactMap { (input, fromState, mapped) -> Reply<State, Input>? in
                    return mapped == nil ? .failure(input, fromState) : nil
                }

            return AnyPublisher(Publishers.Merge(failure, success))
        }

        let reply = recurInputs(internalInputs).share()

        reply
            .compactMap { $0.toState }
//            .sink(receiveValue: currentState.send)    // Comment-Out: Probably Apple's bug
            .sink(receiveValue: { state in
                currentState.value = state
            })
            .cancelled(by: self._cancelBag)

        reply
            .sink(receiveValue: self._replies.send)
            .cancelled(by: self._cancelBag)

        inputs
            .sink(receiveValue: internalInputs.send)
            .cancelled(by: self._cancelBag)

        initialEffect
            .sink(receiveValue: internalInputs.send)
            .cancelled(by: self._cancelBag)
    }

    deinit
    {
        self._replies.send(completion: .finished)
    }
}

// MARK: - Public

extension Harvester
{
    /// Initializer using `Mapping`.
    ///
    /// - Parameters:
    ///   - state: Initial state.
    ///   - inputs: `Publisher` that automaton receives (hot publisher).
    ///   - mapping: Simple `Mapping` that designates next state only (no additional effect).
    public convenience init<Inputs: Publisher>(
        state: State,
        inputs: Inputs,
        mapping: @escaping Mapping
    ) where
        Inputs.Output == Input, Inputs.Failure == Never
    {
        self.init(state: state, inputs: inputs, mapping: _compose(_toEffectMapping, mapping))
    }

    /// Initializer using `EffectMapping`.
    ///
    /// - Parameters:
    ///   - state: Initial state.
    ///   - inputs: `Publisher` that automaton receives.
    ///   - mapping: `EffectMapping` that designates next state and also generates additional effect (cold publisher).
    public convenience init<Inputs: Publisher>(
        state: State,
        inputs: Inputs,
        mapping: @escaping EffectMapping
    ) where
        Inputs.Output == Input, Inputs.Failure == Never
    {
        self.init(
            initial: (state, AnyPublisher<Input, Never>.empty),
            inputs: inputs,
            mapping: mapping
        )
    }

    /// - Todo: `some Publisher & HasCurrentValue <.Output == State, .Failure == Never>` in future Swift
    public var state: Property<State>
    {
        return Property(self._state)
    }

    /// `Reply` signal that notifies either `.success` or `.failure` of state-transition on every input.
    /// - Todo: `some Publisher <.Output == Reply<State, Input>, .Failure == Never>` in future Swift
    public var replies: AnyPublisher<Reply<State, Input>, Never>
    {
        return AnyPublisher(self._replies)
    }
}

extension Harvester {

    /// Basic state-transition function type.
    public typealias Mapping = (State, Input) -> State?

    /// Transducer (input & output) mapping with
    /// **cold publisher** (additional effect) as output,
    /// which may emit next input values for continuous state-transitions.
    public typealias EffectMapping = (State, Input) -> (State, AnyPublisher<Input, Never>)?

}

// MARK: - Private

private func _compose<A, B, C, D>(_ g: @escaping ((C) -> D), _ f: @escaping ((A, B) -> C)) -> ((A, B) -> D)
{
    return { x, y in g(f(x, y)) }
}

private func _toEffectMapping<State, Input>(toState: State?) -> (State, AnyPublisher<Input, Never>)?
{
    if let toState = toState {
        return (toState, .empty)
    }
    else {
        return nil
    }
}
